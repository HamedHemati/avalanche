:mod:`avalanche.evaluation`
===========================

.. py:module:: avalanche.evaluation

.. autoapi-nested-parse::

   The :py:mod:`Evaluation` module provides tools and interfaces to easily define
   new metrics to monitor experiments. In addition, it also provides a set of
   already implemented metrics. These metrics can be used by passing them to
   the `EvaluationPlugin`.



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   metrics/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   metric_definitions/index.rst
   metric_results/index.rst
   metric_utils/index.rst
   plot_utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.evaluation.Metric
   avalanche.evaluation.PluginMetric
   avalanche.evaluation.GenericPluginMetric



.. py:class:: Metric

   Bases: :class:`Protocol[TResult]`

   Definition of a standalone metric.

   A standalone metric exposes methods to reset its internal state and
   to emit a result. Emitting a result does not automatically cause
   a reset in the internal state.

   The specific metric implementation exposes ways to update the internal
   state. Usually, standalone metrics like :class:`Sum`, :class:`Mean`,
   :class:`Accuracy`, ... expose an `update` method.

   The `Metric` class can be used as a standalone metric by directly calling
   its methods.
   In order to automatically integrate the metric with the training and
   evaluation flows, you can use :class:`PluginMetric` class. The class
   receives events directly from the :class:`EvaluationPlugin` and can
   emits values on each callback. Usually, an instance of `Metric` is
   created within `PluginMetric`, which is then responsible for its
   update and results. See :class:`PluginMetric` for more details.

   .. method:: result(self, **kwargs) -> Optional[TResult]

      Obtains the value of the metric.

      :return: The value of the metric.


   .. method:: reset(self, **kwargs) -> None

      Resets the metric internal state.

      :return: None.



.. py:class:: PluginMetric

   Bases: :class:`Metric[TResult]`, :class:`StrategyCallbacks['MetricResult']`, :class:`abc.ABC`

   A metric that can be used together with :class:`EvaluationPlugin`.

   This class leaves the implementation of the `result` and `reset` methods
   to child classes while providing an empty implementation of the callbacks
   invoked by the :class:`EvaluationPlugin`. Subclasses should implement
   the `result`, `reset` and the desired callbacks to compute the specific
   metric.

   Remember to call the `super()` method when overriding
   `after_train_iteration` or `after_eval_iteration`.

   An instance of this class usually leverages a `Metric` instance to update,
   reset and emit metric results at appropriate times
   (during specific callbacks).

   Creates an instance of a plugin metric.

   Child classes can safely invoke this (super) constructor as the first
   experience.

   .. method:: result(self, **kwargs) -> Optional[TResult]
      :abstractmethod:

      Obtains the value of the metric.

      :return: The value of the metric.


   .. method:: reset(self, **kwargs) -> None
      :abstractmethod:

      Resets the metric internal state.

      :return: None.


   .. method:: before_training(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `train` by the `BaseStrategy`. 


   .. method:: before_training_exp(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `train_exp` by the `BaseStrategy`. 


   .. method:: before_train_dataset_adaptation(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `train_dataset_adapatation` by the `BaseStrategy`. 


   .. method:: after_train_dataset_adaptation(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `train_dataset_adapatation` by the `BaseStrategy`. 


   .. method:: before_training_epoch(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `train_epoch` by the `BaseStrategy`. 


   .. method:: before_training_iteration(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before the start of a training iteration by the
      `BaseStrategy`. 


   .. method:: before_forward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `model.forward()` by the `BaseStrategy`. 


   .. method:: after_forward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `model.forward()` by the `BaseStrategy`. 


   .. method:: before_backward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `criterion.backward()` by the `BaseStrategy`. 


   .. method:: after_backward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `criterion.backward()` by the `BaseStrategy`. 


   .. method:: after_training_iteration(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after the end of a training iteration by the
      `BaseStrategy`. 


   .. method:: before_update(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `optimizer.update()` by the `BaseStrategy`. 


   .. method:: after_update(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `optimizer.update()` by the `BaseStrategy`. 


   .. method:: after_training_epoch(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `train_epoch` by the `BaseStrategy`. 


   .. method:: after_training_exp(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `train_exp` by the `BaseStrategy`. 


   .. method:: after_training(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `train` by the `BaseStrategy`. 


   .. method:: before_eval(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `eval` by the `BaseStrategy`. 


   .. method:: before_eval_dataset_adaptation(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `eval_dataset_adaptation` by the `BaseStrategy`. 


   .. method:: after_eval_dataset_adaptation(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `eval_dataset_adaptation` by the `BaseStrategy`. 


   .. method:: before_eval_exp(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `eval_exp` by the `BaseStrategy`. 


   .. method:: after_eval_exp(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `eval_exp` by the `BaseStrategy`. 


   .. method:: after_eval(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `eval` by the `BaseStrategy`. 


   .. method:: before_eval_iteration(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before the start of a training iteration by the
      `BaseStrategy`. 


   .. method:: before_eval_forward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called before `model.forward()` by the `BaseStrategy`. 


   .. method:: after_eval_forward(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after `model.forward()` by the `BaseStrategy`. 


   .. method:: after_eval_iteration(self, strategy: BaseStrategy) -> 'MetricResult'

      Called after the end of an iteration by the
      `BaseStrategy`. 



.. py:class:: GenericPluginMetric(metric, reset_at='experience', emit_at='experience', mode='eval')

   Bases: :class:`PluginMetric[TResult]`

   This class provides a generic implementation of a Plugin Metric.
   The user can subclass this class to easily implement custom plugin
   metrics.

   Creates an instance of a plugin metric.

   Child classes can safely invoke this (super) constructor as the first
   experience.

   .. method:: reset(self, strategy) -> None


   .. method:: result(self, strategy)


   .. method:: update(self, strategy)


   .. method:: before_training(self, strategy: BaseStrategy)

      Called before `train` by the `BaseStrategy`. 


   .. method:: before_training_exp(self, strategy: BaseStrategy)

      Called before `train_exp` by the `BaseStrategy`. 


   .. method:: before_training_epoch(self, strategy: BaseStrategy)

      Called before `train_epoch` by the `BaseStrategy`. 


   .. method:: before_training_iteration(self, strategy: BaseStrategy)

      Called before the start of a training iteration by the
      `BaseStrategy`. 


   .. method:: after_training_iteration(self, strategy: BaseStrategy) -> None

      Called after the end of a training iteration by the
      `BaseStrategy`. 


   .. method:: after_training_epoch(self, strategy: BaseStrategy)

      Called after `train_epoch` by the `BaseStrategy`. 


   .. method:: after_training_exp(self, strategy: BaseStrategy)

      Called after `train_exp` by the `BaseStrategy`. 


   .. method:: after_training(self, strategy: BaseStrategy)

      Called after `train` by the `BaseStrategy`. 


   .. method:: before_eval(self, strategy: BaseStrategy)

      Called before `eval` by the `BaseStrategy`. 


   .. method:: before_eval_exp(self, strategy: BaseStrategy)

      Called before `eval_exp` by the `BaseStrategy`. 


   .. method:: after_eval_exp(self, strategy: BaseStrategy)

      Called after `eval_exp` by the `BaseStrategy`. 


   .. method:: after_eval(self, strategy: BaseStrategy)

      Called after `eval` by the `BaseStrategy`. 


   .. method:: after_eval_iteration(self, strategy: BaseStrategy)

      Called after the end of an iteration by the
      `BaseStrategy`. 


   .. method:: before_eval_iteration(self, strategy: BaseStrategy)

      Called before the start of a training iteration by the
      `BaseStrategy`. 



